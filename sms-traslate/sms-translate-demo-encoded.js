// generated by composer v0.5.2

const composition = {
    "type": "sequence",
    "components": [
        {
            "type": "function",
            "function": {
                "exec": {
                    "kind": "nodejs:default",
                    "code": "p => ({payload: p.Body, number: p.From, version: '2018-05-01'})"
                }
            }
        },
        {
            "type": "retain",
            "components": [
                {
                    "type": "sequence",
                    "components": [
                        {
                            "type": "function",
                            "function": {
                                "exec": {
                                    "kind": "nodejs:default",
                                    "code": "args => ({ text: args.payload, version: args.version})"
                                }
                            }
                        },
                        {
                            "type": "try",
                            "body": {
                                "type": "sequence",
                                "components": [
                                    {
                                        "type": "retain",
                                        "components": [
                                            {
                                                "type": "action",
                                                "name": "/_/watson-language/identify"
                                            }
                                        ]
                                    },
                                    {
                                        "type": "if",
                                        "test": {
                                            "type": "function",
                                            "function": {
                                                "exec": {
                                                    "kind": "nodejs:default",
                                                    "code": "p => p.result.languages[0].language !== 'en'"
                                                }
                                            }
                                        },
                                        "consequent": {
                                            "type": "sequence",
                                            "components": [
                                                {
                                                    "type": "function",
                                                    "function": {
                                                        "exec": {
                                                            "kind": "nodejs:default",
                                                            "code": "p => ({ model_id: p.result.languages[0].language + '-' + 'en', \n                      text: [p.params.text], \n                      version: p.params.version})"
                                                        }
                                                    }
                                                },
                                                {
                                                    "type": "action",
                                                    "name": "/_/watson-language/translate"
                                                }
                                            ]
                                        },
                                        "alternate": {
                                            "type": "sequence",
                                            "components": [
                                                {
                                                    "type": "function",
                                                    "function": {
                                                        "exec": {
                                                            "kind": "nodejs:default",
                                                            "code": "p => ({payload: p.params.text})"
                                                        }
                                                    }
                                                },
                                                {
                                                    "type": "action",
                                                    "name": "/_/sms-translate/en2shakespeare"
                                                }
                                            ]
                                        }
                                    }
                                ]
                            },
                            "handler": {
                                "type": "function",
                                "function": {
                                    "exec": {
                                        "kind": "nodejs:default",
                                        "code": "err => ({payload: 'Sorry, we cannot translate your text'})"
                                    }
                                }
                            }
                        }
                    ]
                }
            ]
        },
        {
            "type": "function",
            "function": {
                "exec": {
                    "kind": "nodejs:default",
                    "code": "({ params, result }) => ({ Body: result.translations[0], number: params.number })"
                }
            }
        },
        {
            "type": "action",
            "name": "/_/sms-translate/sendsms"
        }
    ]
}

// do not edit below this point

const main=function e(){
const t=require("fs"),n=require("util"),s=require("semver"),o=e=>"object"==typeof e&&null!==e&&!Array.isArray(e)
;class i extends Error{constructor(e,t){super(e+(void 0!==t?"\nArgument: "+n.inspect(t):""))}}class r{
static[Symbol.hasInstance](e){return e.constructor&&e.constructor.name===r.name}constructor(e){return Object.assign(this,e)}
visit(e,t){const n=e[this.type];n.components&&(this.components=this.components.map(t))
;for(let e of n.args||[])void 0===e.type&&(this[e._]=t(this[e._],e._))}}const a=[],c={task(e){
if(arguments.length>1)throw new i("Too many arguments");if(null===e)return this.empty();if(e instanceof r)return e
;if("function"==typeof e)return this.function(e);if("string"==typeof e)return this.action(e);throw new i("Invalid argument",e)
},function(e){if(arguments.length>1)throw new i("Too many arguments")
;if("function"==typeof e&&-1!==(e=`${e}`).indexOf("[native code]"))throw new i("Cannot capture native function",e)
;if("string"==typeof e&&(e={kind:"nodejs:default",code:e}),!o(e))throw new i("Invalid argument",e);return new r({
type:"function",function:{exec:e}})},action(e,n={}){if(arguments.length>2)throw new i("Too many arguments")
;if(!o(n))throw new i("Invalid argument",n);let s;if(e=p(e),Array.isArray(n.sequence)&&(s={kind:"sequence",
components:n.sequence.map(p)}),"string"==typeof n.filename&&(s=t.readFileSync(n.filename,{encoding:"utf8"})),
"function"==typeof n.action&&-1!==(s=`const main = ${n.action}`).indexOf("[native code]"))throw new i("Cannot capture native function",n.action)
;("string"==typeof n.action||o(n.action))&&(s=n.action),"string"==typeof s&&(s={kind:"nodejs:default",code:s});const a={
type:"action",name:e};return s&&(a.action={exec:s}),n.async&&(a.async=!0),new r(a)},composition(e,t,n={}){
if(arguments.length>3)throw new i("Too many arguments");if(!o(n))throw new i("Invalid argument",n);const s={type:"composition",
name:e=p(e),composition:this.task(t)};return n.async&&(s.async=!0),new r(s)},_empty(){return this.sequence()},_seq(e){
return this.sequence(...e.components)},_value(e){return this._literal(e)},_literal(e){return this.let({value:e.value
},()=>value)},_retain(e){return this.let({params:null},e=>{params=e},this.mask(...e.components),e=>({params:params,result:e}))
},_retain_catch(e){return this.seq(this.retain(this.finally(this.seq(...e.components),e=>({result:e
}))),({params:e,result:t})=>({params:e,result:t.result}))},_if(e){return this.let({params:null},e=>{params=e
},this.if_nosave(this.mask(e.test),this.seq(()=>params,this.mask(e.consequent)),this.seq(()=>params,this.mask(e.alternate))))},
_while(e){return this.let({params:null},e=>{params=e
},this.while_nosave(this.mask(e.test),this.seq(()=>params,this.mask(e.body),e=>{params=e})),()=>params)},_dowhile(e){
return this.let({params:null},e=>{params=e},this.dowhile_nosave(this.seq(()=>params,this.mask(e.body),e=>{params=e
}),this.mask(e.test)),()=>params)},_repeat(e){return this.let({count:e.count
},this.while(()=>count-- >0,this.mask(this.seq(...e.components))))},_retry(e){return this.let({count:e.count},e=>({params:e
}),this.dowhile(this.finally(({params:e})=>e,this.mask(this.retain_catch(...e.components))),({result:e})=>void 0!==e.error&&count-- >0),({result:e})=>e)
},combinators:{},deserialize(e){if(arguments.length>1)throw new i("Too many arguments")
;return(e=new r(e)).visit(this.combinators,e=>this.deserialize(e)),e},label(e){
if(arguments.length>1)throw new i("Too many arguments");if(!(e instanceof r))throw new i("Invalid argument",e)
;const t=e=>(n,s,o)=>((n=new r(n)).path=e+(void 0!==s?void 0===o?`.${s}`:`[${s}]`:""),n.visit(this.combinators,t(n.path)),n)
;return t("")(e)},lower(e,t=[]){if(arguments.length>2)throw new i("Too many arguments")
;if(!(e instanceof r))throw new i("Invalid argument",e)
;if(!Array.isArray(t)&&"boolean"!=typeof t&&"string"!=typeof t)throw new i("Invalid argument",t);if(!1===t)return e
;!0!==t&&""!==t||(t=[]),"string"==typeof t&&(t=Object.keys(this.combinators).filter(e=>s.gte(t,this.combinators[e].since)))
;const n=e=>{for(e=new r(e);t.indexOf(e.type)<0&&this[`_${e.type}`];){const t=e.path;e=this[`_${e.type}`](e),
void 0!==t&&(e.path=t)}return e.visit(this.combinators,n),e};return n(e)},register(e){return e.combinators&&l(e.combinators()),
e.composer&&Object.assign(this,e.composer({ComposerError:i,Composition:r})),a.push(e),this}};function p(e){
if("string"!=typeof e)throw new i("Name must be a string");if(0==e.trim().length)throw new i("Name is not valid")
;const t=(e=e.trim()).split("/"),n=t.length,s="/"==e[0];if(n<1||n>4||s&&2==n||!s&&4==n)throw new i("Name is not valid")
;t.forEach(function(e,t){if(t>0&&0==e.trim().length)throw new i("Name is not valid")});const o=t.join("/")
;return s?o:n<3?`/_/${o}`:`/${o}`}function l(e){Object.assign(c.combinators,e);for(let t in e){const n=e[t]
;c[t]=c[t]||function(){const e=new r({type:t}),s=n.args&&n.args.length||0
;if(!n.components&&arguments.length>s)throw new i("Too many arguments");for(let t=0;t<s;++t){const s=n.args[t],o=arguments[t]
;if(void 0!==o||!s.optional||void 0===s.type)switch(s.type){case void 0:e[s._]=this.task(s.optional?o||null:o);continue
;case"value":if("function"==typeof o)throw new i("Invalid argument",o);e[s._]=void 0===o?{}:o;continue;case"object":
if(null===o||Array.isArray(o))throw new i("Invalid argument",o);default:if(typeof o!==s.type)throw new i("Invalid argument",o)
;e[s._]=o}}return n.components&&(e.components=Array.prototype.slice.call(arguments,s).map(e=>c.task(e))),e}}}return l({empty:{
since:"0.4.0"},seq:{components:!0,since:"0.4.0"},sequence:{components:!0,since:"0.4.0"},if:{args:[{_:"test"},{_:"consequent"},{
_:"alternate",optional:!0}],since:"0.4.0"},if_nosave:{args:[{_:"test"},{_:"consequent"},{_:"alternate",optional:!0}],
since:"0.4.0"},while:{args:[{_:"test"},{_:"body"}],since:"0.4.0"},while_nosave:{args:[{_:"test"},{_:"body"}],since:"0.4.0"},
dowhile:{args:[{_:"body"},{_:"test"}],since:"0.4.0"},dowhile_nosave:{args:[{_:"body"},{_:"test"}],since:"0.4.0"},try:{args:[{
_:"body"},{_:"handler"}],since:"0.4.0"},finally:{args:[{_:"body"},{_:"finalizer"}],since:"0.4.0"},retain:{components:!0,
since:"0.4.0"},retain_catch:{components:!0,since:"0.4.0"},let:{args:[{_:"declarations",type:"object"}],components:!0,
since:"0.4.0"},mask:{components:!0,since:"0.4.0"},action:{args:[{_:"name",type:"string"},{_:"options",type:"object",optional:!0
}],since:"0.4.0"},composition:{args:[{_:"name",type:"string"},{_:"composition"},{_:"options",type:"object",optional:!0}],
since:"0.4.0"},repeat:{args:[{_:"count",type:"number"}],components:!0,since:"0.4.0"},retry:{args:[{_:"count",type:"number"}],
components:!0,since:"0.4.0"},value:{args:[{_:"value",type:"value"}],since:"0.4.0"},literal:{args:[{_:"value",type:"value"}],
since:"0.4.0"},function:{args:[{_:"function",type:"object"}],since:"0.4.0"}}),{client:function(){
const n=require("os"),s=require("path"),o=require("uglify-es").minify,p=require("./package.json").version
;return Object.assign(c,{openwhisk(e){let o,a;try{
const e=process.env.WSK_CONFIG_FILE||s.join(n.homedir(),".wskprops"),i=t.readFileSync(e,{encoding:"utf8"}).split("\n")
;for(let e of i){let t=e.trim().split("=");2===t.length&&("APIHOST"===t[0]?o=t[1]:"AUTH"===t[0]&&(a=t[1]))}}catch(e){}
process.env.__OW_API_HOST&&(o=process.env.__OW_API_HOST),process.env.__OW_API_KEY&&(a=process.env.__OW_API_KEY)
;const c=require("openwhisk")(Object.assign({apihost:o,api_key:a},e));return c.compositions=new class{constructor(e,t){
this.actions=e.actions,this.composer=t}deploy(e,t){if(arguments.length>2)throw new i("Too many arguments")
;if(!(e instanceof r))throw new i("Invalid argument",e)
;if("composition"!==e.type)throw new i("Cannot deploy anonymous composition");const n=this.composer.encode(e,t)
;return n.actions.reduce((e,t)=>e.then(()=>this.actions.delete(t).catch(()=>{})).then(()=>this.actions.update(t)),Promise.resolve()).then(()=>n)
}}(c,this),c},encode(t,n=[]){if(arguments.length>2)throw new i("Too many arguments")
;if(!(t instanceof r))throw new i("Invalid argument",t);t=this.lower(t,n);const s=[],c=t=>{
if((t=new r(t)).visit(this.combinators,c),"composition"===t.type){let n=`const main=(${e})().server(`
;for(let e of a)n+=`{plugin:new(${e.constructor})()`,e.configure&&(n+=`,config:${JSON.stringify(e.configure())}`),n+="},"
;n=o(`${n})`,{output:{max_line_len:127}
}).code,n=`// generated by composer v${p}\n\nconst composition = ${JSON.stringify(c(t.composition),null,4)}\n\n// do not edit below this point\n\n${n}`,
t.action={exec:{kind:"nodejs:default",code:n},annotations:[{key:"conductor",value:t.composition},{key:"composer",value:p}]},
delete t.composition,t.type="action"}return"action"===t.type&&t.action&&(s.push({name:t.name,action:t.action}),
delete t.action),t};return{composition:t=c(t),actions:s}},get version(){return p}}),c},server:function(){function e(e,t){
return e.slice(-1)[0].next=1,e.push(...t),e}const t={compile(t){return 0===arguments.length?[{type:"empty"
}]:1===arguments.length?this[t.type](t):Array.prototype.map.call(arguments,e=>this.compile(e)).reduce(e)},sequence(t){
return e([{type:"pass",path:t.path}],this.compile(...t.components))},action:e=>[{type:"action",name:e.name,async:e.async,
path:e.path}],function:e=>[{type:"function",exec:e.function.exec,path:e.path}],finally(t){var n=this.compile(t.body)
;const s=this.compile(t.finalizer);var o=[[{type:"try",path:t.path}],n,[{type:"exit"}],s].reduce(e)
;return o[0].catch=o.length-s.length,o},let(t){var n=this.compile(...t.components);return[[{type:"let",let:t.declarations,
path:t.path}],n,[{type:"exit"}]].reduce(e)},mask(t){var n=this.compile(...t.components);return[[{type:"let",let:null,
path:t.path}],n,[{type:"exit"}]].reduce(e)},try(t){var n=this.compile(t.body);const s=e(this.compile(t.handler),[{type:"pass"
}]);var o=[[{type:"try",path:t.path}],n,[{type:"exit"}]].reduce(e);return o[0].catch=o.length,o.slice(-1)[0].next=s.length,
o.push(...s),o},if_nosave(t){var n=this.compile(t.consequent),s=e(this.compile(t.alternate),[{type:"pass"}]),o=[[{type:"pass",
path:t.path}],this.compile(t.test),[{type:"choice",then:1,else:n.length+1}]].reduce(e);return n.slice(-1)[0].next=s.length,
o.push(...n),o.push(...s),o},while_nosave(t){var n=this.compile(t.body),s=[[{type:"pass",path:t.path}],this.compile(t.test),[{
type:"choice",then:1,else:n.length+1}]].reduce(e);return n.slice(-1)[0].next=1-s.length-n.length,s.push(...n),s.push(...[{
type:"pass"}]),s},dowhile_nosave(t){var n=this.compile(t.test),s=[[{type:"pass",path:t.path}],this.compile(t.body),n,[{
type:"choice",then:1,else:2}]].reduce(e);return s.slice(-1)[0].then=1-s.length,s.slice(-1)[0].else=1,s.push(...[{type:"pass"
}]),s}},n=require("openwhisk");let s;const i={choice({p:e,node:t,index:n}){e.s.state=n+(e.params.value?t.then:t.else)},
try({p:e,node:t,index:n}){e.s.stack.unshift({catch:n+t.catch})},let({p:e,node:t,index:n}){e.s.stack.unshift({
let:JSON.parse(JSON.stringify(t.let))})},exit({p:e,node:t,index:n}){
if(0===e.s.stack.length)return l(`State ${n} attempted to pop from an empty stack`);e.s.stack.shift()},
action:({p:e,node:t,index:o})=>t.async?(s||(s=n({ignore_certs:!0})),s.actions.invoke({name:t.name,params:e.params
}).catch(e=>(console.error(e),{error:`An exception was caught at state ${o} (see log for details)`})).then(t=>(e.params=t,u(e),
h(e)))):{action:t.name,params:e.params,state:{$resume:e.s}},
function:({p:e,node:t,index:n})=>Promise.resolve().then(()=>(function(e,t){this.require=require;const n=[];let s=0
;for(let e of t.s.stack)null===e.let?s++:void 0!==e.let&&(0===s?n.push(e):s--);function o(e,t){
const s=n.find(t=>void 0!==t.let&&void 0!==t.let[e]);void 0!==s&&(s.let[e]=JSON.parse(JSON.stringify(t)))}
const i=n.reduceRight((e,t)=>t.let?Object.assign(e,t.let):e,{});let r="(function(){try{"
;for(const e in i)r+=`var ${e}=arguments[1]['${e}'];`;r+=`return eval((${e}))(arguments[0])}finally{`
;for(const e in i)r+=`arguments[1]['${e}']=${e};`;r+="}})";try{return(0,eval)(r)(t.params,i)}finally{for(const e in i)o(e,i[e])
}})(t.exec.code,e)).catch(e=>(console.error(e),{error:`An exception was caught at state ${n} (see log for details)`
})).then(t=>("function"==typeof t&&(t={error:`State ${n} evaluated to a function`}),
e.params=JSON.parse(JSON.stringify(void 0===t?e.params:t)),u(e),h(e))),empty({p:e,node:t,index:n}){u(e)},
pass({p:e,node:t,index:n}){}},r=[];for({plugin:plugin,config:config}of arguments)if(c.register(plugin),
plugin.compiler&&Object.assign(t,plugin.compiler()),plugin.conductor){const e=plugin.conductor(config)
;e._finish&&(r.push(e._finish),delete e._finish),Object.assign(i,e)}
const a=t.compile(c.lower(c.label(c.deserialize(composition)))),p=e=>Promise.reject({code:400,error:e
}),l=e=>Promise.reject((e=>({code:"number"==typeof e.code&&e.code||500,
error:"string"==typeof e.error&&e.error||e.message||"string"==typeof e&&e||"An internal error occurred"}))(e));function u(e){
if(o(e.params)||(e.params={value:e.params}),void 0!==e.params.error)for(e.params={error:e.params.error},
e.s.state=void 0;e.s.stack.length>0&&"number"!=typeof(e.s.state=e.s.stack.shift().catch););}function h(e){
if(void 0===e.s.state)return console.log("Entering final state"),console.log(JSON.stringify(e.params)),
r.reduce((t,n)=>t.then(()=>n(e)),Promise.resolve()).then(()=>e.params.error?e.params:{params:e.params});const t=a[e.s.state]
;void 0!==t.path&&console.log(`Entering composition${t.path}`);const n=e.s.state
;return e.s.state=void 0===t.next?void 0:e.s.state+t.next,i[t.type]({p:e,index:n,node:t,inspect:u,step:h})||h(e)}
return e=>Promise.resolve().then(()=>(function(e){const t={s:{state:0,stack:[]},params:e};if(void 0!==e.$resume){
if(!o(e.$resume))return p("The type of optional $resume parameter must be object");const n=e.$resume.stack
;if(Object.assign(t.s,e.$resume),
n&&(t.s.state=e.$resume.state),void 0!==t.s.state&&"number"!=typeof t.s.state)return p("The type of optional $resume.state parameter must be number")
;if(!Array.isArray(t.s.stack))return p("The type of $resume.stack must be an array");delete e.$resume,n&&u(t)}return h(t)
})(e)).catch(l)}}}().server();
